\NeedsTeXFormat{LaTeX2e}

\documentclass{new_tlp}

\usepackage{url}
%\usepackage{named}
\usepackage{yfonts}

\newtheorem{lem}{Lemma}
\newtheorem{thm}{Theorem}
\newtheorem{cor}{Corollary}

\def\ar{\leftarrow}
\def\lrar{\leftrightarrow}
\def\beq{\begin{equation}}
\def\eeq#1{\label{#1}\end{equation}}
\def\ba{\begin{array}}
\def\ea{\end{array}}
\def\gringo{{\sc gringo}}
\def\clingo{{\sc clingo}}
\def\anthem{{\sc anthem}}
\def\vampire{{\sc vampire}}
\def\num{\overline}
\def\p2f{\hbox{p2f}}
\def\no{\emph{not\/}}
\def\head{\emph{Head\/}}
\def\body{\emph{Body\/}}
% \def\uc{\widetilde\forall}
\def\Sfr{\textfrak{S}}
\def\val#1#2{\emph{val\,}_{#1}({#2})}

\newcommand{\I}{\mathcal{I}}
\newcommand{\J}{\mathcal{J}}
\newcommand{\M}{\mathcal{M}}
\newcommand{\PP}{\mathcal{P}}

\hyphenation{lif-schitz}

\begin{document}

\title{\bf External Behavior of a Logic Program\\
  and Verification of Refactoring}
\author[J. Fandinno, Z. Hansen, Y. Lierler, V. Lifschitz, N. Temple]{Jorge Fandinno, Zachary Hansen, Yuliya Lierler\\
  University of Nebraska Omaha\\ \\
Vladimir Lifschitz and Nathan Temple\\ University of Texas at Austin}
\date{}

\maketitle

\begin{center}INCOMPLETE DRAFT\end{center}

\begin{abstract}
  Refactoring is modifying a program without changing its external behavior.
  In this paper, we
  make the concept of external behavior precise for a simple answer set
  programming language.  Then we describe a proof assistant for the
  task of verifying
  that refactoring a program in that language is performed correctly.
\end{abstract}
  
\section{Introduction}

This note is about the process of refactoring in the context of answer set
programming (ASP) \cite{mar99,nie99}, %bar03,geb12,gel14,lif19a
that is, about modifying an ASP program without changing
its external behavior.  Refactoring a program usually involves a series of
small changes that improve its structure or performance.  In answer set
programming, refactoring can serve also for converting code that is
semantically correct but cannot be executed by the existing solvers into an
executable program.  For example, the program
\begin{verbatim}
  composite(I*J) :- I > 1, J > 1.
        prime(I) :- I = a..b, not composite(I).
\end{verbatim}
in the input language of the answer set solver {\sc clingo} \cite{geb12}
is a semantically correct definition of the set of primes in the
interval $\{a,\dots,b\}$, assuming that $a>1$.  This program
is not executable, because the variables in
the rule defining \verb|composite/1| are unsafe.  The error message
\begin{verbatim}
  grounding stopped because of errors
\end{verbatim}
will not disappear even if we indicate that the predicate
\verb|composite/1| is auxiliary by appending the directive
\begin{verbatim}
  #show prime/1.
\end{verbatim}
A safe program can be obtained by rewriting the first rule as
\begin{verbatim}
  composite(I*J) :- I = 2..b, J = 2..b.
\end{verbatim}
This is an example of refactoring, because this modification
does not change the extent of \verb|prime/1|.
As the next refactoring step, we can optimize the program using the
fact that every composite
number in the interval $\{a,\dots,b\}$ has a divisor in the interval
$\{2,\dots\lfloor \sqrt b\rfloor\}$:
\begin{verbatim}
       sqrt_b(M) :- M = 1..b, M*M <= b, (M+1)*(M+1) > b.
  composite(I*J) :- sqrt_b(M), I = 2..M, J = 2..b.
        prime(I) :- I = a..b, not composite(I).
\end{verbatim}

We are interested in the problem of verifying the correctness of
refactoring steps like these. We would like to make the concept of external
behavior of a logic program precise, and to
design software tools for verifying that a proposed modification of an
ASP program would have no effect on its external behavior.

In the Abstract Gringo language \cite{geb15}, a program is defined as
a set of rules, so that a program
includes neither directives nor comments.  Under this narrow definition,
the program itself does not tell us which predicate symbols are meant to
represent the output, and which symbols are considered
auxiliary.  But this difference is essential for us, because changing
auxiliary predicates does not indicate a mistake in the process of
refactoring.

Furthermore, the rules of a program do not show what kind of input is
supposed to be provided for it.
Generally, an input for an ASP program can be specified in two ways.
First, some symbolic constants, such as {\tt a} and {\tt b} in the
programs above, may be meant to serve as placeholders for elements of
the input.
There is no way to decide by looking at the rules
which symbolic constants are supposed to play this role.
Second, some predicate symbols occurring in the program may occur in
the bodies of rules only, not in the heads.  The extents of such
predicates may be specified as part of input when we run the program.

Some inputs may not conform to the programmer's assumptions about
the intended use of the program.  For instance, the program above is
expected to be applied to intervals $\{a,\dots,b\}$ such that $a>1$;
we are not interested in the cases when the placeholder~{\tt a} is
replaced by an integer that is not greated than~1 or by a symbolic constant.
Stable models of a program for ``bad'' inputs are not related to its
external behavior if the program is used as intended.

To sum up, what we consider external behavior of a set of rules
depends on how these rules are meant to be used.

In this paper, we make this idea precise
for the subset of
Abstract Gringo called mini-\gringo\ \cite[Section~2]{fan20},
\cite[Section~2.1]{fan22}.   Then we describe the proof assistant
{\sc anthem-p2p}, which uses
the theorem prover \vampire\ \cite{vor13}
 to verify that two mini-\gringo\ programs have the
 same external behavior.  The three versions of the prime number program
 above are used as a running example.  To make the paper more
 self-contained, we have reviewed some background material in
 Appendices~\ref{appa}--\ref{appc}.

\section{On the syntax of mini-\gringo}\label{sec:mg}

There are minor syntactic differences between
mini-\gringo\ and the input language of the grounder \gringo,
explained by the fact the former is designed for theoretical studies, and the
latter for actual programming.
For example, the optimized prime number program from the introduction,
rewritten in the syntax of mini-\gringo, becomes
$$\ba {rcl}
\emph{sqrt\_b\/}(M) &\ar& M = \num  1\,..\,b \,\land\, M\times M \leq b
          \,\land\, (M+\num 1)\times(M+\num 1) > b,\\
          \emph{composite\/}(I\times J) &\ar& \emph{sqrt\_b\/}(M) \,\land\,
                 I = \num 2\,..\,N \,\land\, J = \num 2\,..\,b,\\
                 \emph{prime\/}(I) &\ar& I = a\,..\,b
                 \,\land\, \emph{not}\ \emph{composite\/}(I).
\ea
$$
The symbols $\num 1$ and $\num 2$ are ``numerals''---syntactic objects
representing integers. Distinguishing between an integer and the corresponding
numeral is sometimes convenient.  In examples of rules and programs, we will
freely switch between the two styles.

In the definition of mini-\gringo,
\emph{precomputed terms} are numerals,
  symbolic constants, and the symbols \emph{inf}, \emph{sup}.
  We assume that a total order on precomputed terms in chosen, such that
  \emph{inf} is its least element, \emph{sup} is its greatest element, and,
 for all integers~$m$ and~$n$,   $\num m < \num n$ iff $m<n$.
A  \emph{precomputed atom} is an expression of the form $p({\bf t})$, where~$p$
  is a symbolic constant and~$\bf t$ is a tuple of precomputed terms.
  A \emph{predicate symbol} is a pair $p/n$, where~$p$ is a symbolic
  constant and~$n$ is a nonnegative integer.  About an atom $p({\bf t})$ we
  say that it \emph{contains} $p/n$ if the tuple~$\bf t$ consists of~$n$
  terms.

\section{User guides}\label{sec:ug}

{\bf Definition 1}$\;$
A \emph{user guide} is a quadruple
\beq
(\emph{PH},\emph{In},\emph{Out},\emph{Dom\/})
\eeq{ug}
where
\begin{itemize}
\item \emph{PH} is a finite set of symbolic constants, called
  \emph{placeholders},
\item \emph{In} and \emph{Out} are disjoint finite sets of predicate
  symbols, called \emph{input symbols} and \emph{output symbols},
  and
\item \emph{Dom} is a set such that each of its elements is a pair $(v,\I)$,
  where
  \begin{itemize}
    %%%
  \item [(i)]$v$ is a function that maps elements of~\emph{PH} to
      precomputed terms that do not belong to~\emph{PH}, and
    \item  [(ii)] $\I$ is a subset of the set of precomputed atoms that contain
      an input symbol and do not contain placeholders.
\end{itemize}
\end{itemize}

The set \emph{Dom} is the \emph{domain} of the user guide, and
pairs $(v,\I)$ satisfying conditions~(i) and~(ii) are called \emph{inputs}
\cite[Section~5.2]{fan20}.
An input $(v,\I)$ represents a way to choose the values of
placeholders and the extents of input predicates: for every
placeholder~$c$, specify $v(c)$ as its value, and add the atoms~$\I$
to the rules of the program as facts.  If~$\Pi$ is a mini-\gringo\ program
then $v(\Pi)$ stands for the mini-\gringo\ program obtained from~$\Pi$ by
replacing every occurrence of every constant~$c$ in the domain of~$v$
by~$v(c)$
\cite[Section~2.4]{fan22}.  Using this notation, we can say that
choosing $(v,\I)$ as input for~$\Pi$ amounts to
replacing~$\Pi$ by the program $v(\Pi)\cup\I$.

To use a program in accordance with user guide~(\ref{ug})
means to run it for inputs that belong to \emph{Dom}.  The
inputs that do not belong to \emph{Dom} are not related to the
external behavior of the program when it is used as intended.

\medskip\noindent{\bf Example 1}$\;$ The intended use of the
programs discussed in the introduction is
described by user guide~(\ref{ug}) with
$$\emph{PH} = \{a,b\},\ \emph{In} = \emptyset,\
  \emph{Out} = \{\emph{prime}/1\},$$
and with the domain consisting of the inputs $(v,\emptyset)$ such that
$v(a)$ and $v(b)$ are numerals, and $v(a)>\num 1$.  We will denote this
user guide by $\emph{UG}_p$.

\medskip\noindent{\bf Example 2}$\;$ We would like to describe the meaning
of the word \emph{orphan} by a logic program \cite[Section ??]{gel14}.
The intended use of such a
program can be described by user guide~(\ref{ug}) with
$$\emph{PH} = \emptyset,\
\emph{In} = \{\emph{father/2},\emph{mother/2}, \emph{living/1}\},\
\emph{Out} = \{\emph{orphan/1}\},$$
and with the domain consisting all inputs.    We will denote this
user guide by~$\emph{UG}_o$.  In the next two sections, we examine
two possible definitions of \hbox{\emph{orphan/1}}
and consider the question of their
equivalence with respect to $\emph{UG}_o$.
\medskip

User guides are closely related to
lp-functions \cite[Section~2]{gel02}
and to io-programs \cite[Section~5]{fan20} (see Appendix~\ref{appc} for
a review).
    Combining a set of rules with a user guide is similar to using these
    rules as part of
    an lp-function or an io-program.

\section{External behavior}

    An \emph{output atom} of a user guide~\emph{UG} is a precomputed atom
    that contains an output symbol of~\emph{UG}.
    
    \medskip\noindent{\bf Definition 2}$\;$
    Let~$(v,\I)$ be an input in the domain
    of a user guide~\emph{UG}, and let~$\Pi$ be
a mini-\gringo\ program such that the heads of its rules do not
contain input symbols of~\emph{UG}.  The \emph{external behavior} of~$\Pi$
for the user guide~\emph{UG} and the input~$(v,\I)$ is the collection
of all sets that can be represented as the intersection of a stable model
of $v(\Pi)\cup\I$ with the set of output atoms of~\emph{UG}.

\medskip\noindent{\bf Example~1, continued}$\;$ If~$\Pi$ is one of the
three prime number programs from the introduction, and $(v,\I)$ is an
input in the domain of $\emph{UG}_p$, then the program $v(\Pi)\cup\I$
is $v(\Pi)$, and it has a unique stable model.  If~$v$ is defined by
$$v(a)=\num{10},\ v(b)=\num{15},$$
then that stable model includes the atoms $\emph{prime}(\num{11})$,
$\emph{prime}(\num{13})$, and some atoms containing
$\emph{composite}/1$.  The external behavior of each of the programs
for this input is
$$\{\{\emph{prime}(\num{11}),\emph{prime}(\num{13})\}\}.$$
For the safe and optimized versions, this external behavior
can be calculated by instructing \clingo\ to
find all answers for the file obtained from the program by appending the
declarations
\begin{verbatim}
  #const a = 10.
  #const b = 15.
  #show prime/1.
\end{verbatim}

\medskip\noindent{\bf Example~2, continued}$\;$ If~$\Pi$ is the program
\beq\ba l
\verb|parent_living(X) :- father(Y,X), living(Y).|\\
\verb|parent_living(X) :- mother(Y,X), living(Y).|\\
\verb|       orphan(X) :- living(X), not parent_living(X).|
\ea\eeq{orphan1}
and $(v,\I)$ is an input in the domain of $\emph{UG}_o$, then the
program $v(\Pi)\cup\I$ is $\Pi\cup\I$, and it has a unique stable model.
If~$\I$ is
\beq\ba l
\{\emph{father\/}(\emph{jacob},\emph{joseph}),
\emph{mother\/}(\emph{rachel},\emph{joseph}),\\
\quad \quad \emph{living}(\emph{jacob}),
\emph{living}(\emph{rachel}),
\emph{living}(\emph{joseph})\},
\ea\eeq{oi}
then that stable model includes the atoms
$$\emph{orphan\/}(\emph{jacob}),\ \emph{orphan\/}(\emph{rachel})$$
and some atoms containing predicate symbols other than \emph{orphan/1}.
The external behavior of this program for $\emph{UG}_o$ and input~(\ref{oi})
is
\beq
\{\{\emph{orphan\/}(\emph{jacob}),\emph{orphan\/}(\emph{rachel})\}\}.
\eeq{ebor}
It can be calculated by instructing \clingo\ to
find all answers for the file obtained from the program by appending the
facts
\begin{verbatim}
  father(jacob,joseph).
  mother(rachel,joseph).
  living(jacob; rachel; joseph).
\end{verbatim}
and the directive
\begin{verbatim}
  #show orphan/1.
\end{verbatim}

\medskip\noindent{\bf Example~3}$\;$
Assume that \emph{UG} has no placeholders and no input symbols,
that its set of output symbols includes all predicate symbols occurring
in~$\Pi$, and that its domain is $\{(\emptyset,\emptyset)\}$.  Then
the external
behavior of~$\Pi$ with respect to~\emph{UG} and $(\emptyset,\emptyset)$
is the set of stable models of~$\Pi$.

\section{Equivalence}

\noindent{\bf Definition 3}$\;$
Let~\emph{UG} be a user guide, and let~$\Pi_1$, $\Pi_2$ be mini-\gringo\
programs such that the heads of their rules do not contain input symbols
of~\emph{UG}.  We say that~$\Pi_1$ is \emph{equivalent to~$\Pi_2$ with
respect to}~\emph{UG} if, for every input $(v,\I)$ in the domain of~\emph{UG},
the external behavior of $\Pi_1$ for~\emph{UG} and~$(v,\I)$ is the
same as the external behavior of~$\Pi_2$.

\medskip\noindent{\bf Example~1, continued}$\;$ The three programs from the
introduction are equivalent to each other with respect to $\emph{UG}_p$.
We will see that this claim can be verified using the automated reasoning
tools {\sc anthem-p2p} and \vampire.

\medskip\noindent{\bf Example~2, continued}$\;$ Perhaps surprisingly,
the one-rule program
\beq\ba l
\verb|orphan(X) :- living(X), father(Y,X), mother(Z,X),|\\
\verb|             not living(Y), not living(Z).|
\ea\eeq{orphan2}
is not equivalent to~(\ref{orphan1}) with respect to $\emph{UG}_o$.
Indeed, the external behavior of this program with respect
to $\emph{UG}_o$ and input~(\ref{oi}) is $\{\emptyset\}$, which
is different from~(\ref{ebor}).  We will see
that {\sc anthem-p2p} and \vampire\
can help us clarify the relationship between
programs~(\ref{orphan1}) and~(\ref{orphan2}).

\medskip\noindent{\bf Example~3, continued}$\;$
Assume that \emph{UG} has no placeholders and no input symbols,
that its set of output symbols includes all predicate symbols occurring
in~$\Pi_1$ and $\Pi_2$, and that its domain is $\{(\emptyset,\emptyset)\}$.
Then~$\Pi_1$ and~$\Pi_2$ are equivalent to each other with
respect to~\emph{UG} iff they have the same stable models.

\medskip
We understand refactoring a mini-\gringo\ program with respect to a
  user guide~\emph{UG} as replacing it by a program that is equivalent
  to it with respect to~\emph{UG}.

This equivalence relation is essentially an
example of relativized uniform equivalence with projection
\cite{oet08}, except that the language discussed in that paper includes
neither arithmetic operations nor placeholders.
It is \emph{uniform} equivalence, because the programs are extended by
adding facts, rather than more complex rules; \emph{relativized},
because these
  facts~$\I$ are assumed to be atoms containing input symbols,
  not arbitrary atoms; \emph{with projection}, because
  we look at the output atoms in the stable model, not the entire model.

\section{Formal notation for user guides} \label{sec:fn}

To design software for verifying the equivalence of
programs with respect to a user guide, we need to
represent user guides in formal notation.   The format that we chose for
user guide files is similar to the format of
specification files, defined by \cite{fan20} [2020].
Placeholders
and input symbols are represented by \verb|input| statements, for instance:
\begin{verbatim}
  input: n.
  input: living/1, father/2, mother/2.
\end{verbatim}
Output symbols are represented by \verb|output| statements:
\begin{verbatim}
  output: prime/1.
\end{verbatim}
There can be several statements of both kinds in a user guide file, in any
order.

The question of representing the domain \emph{Dom} by a string of
characters is more difficult, because the domain is a set of inputs,
which is generally infinite.
Our approach is to define ``assumptions'' as sentences of an
appropriate first-order language, and characterize the domain by a
list of assumptions; an input belongs to the domain iff it
satisfies all assumptions in that set.

For any set~$\PP$ of predicate symbols, by $\sigma_0(\PP)$ we denote the
subsignature of the two-sorted signature~$\sigma_0$, described in
Appendix~\ref{appa}, in which the set of predicate symbols
is limited to the comparison symbols and the symbols from~$\PP$.
In this paper, an \emph{assumption} is a sentence over the
signature~$\sigma_0(\emph{In\/})$.
Besides \verb|input| and \verb|output| statements, a user guide
file may include one or more statements consisting of the word
\verb|assume| followed by a list of assumptions.

To use assumptions as conditions on an input, we need to relate inputs
to interpretations in the sense of first-order logic.
If~$v$ is a function that maps elements of some set~\emph{PH} of
symbolic constants to symbolic constants, and~$\I$ is a subset of the set of
precomputed atoms that contain a predicate symbol from~$\PP$,
then there exists a unique interpretation~$I$ of~$\sigma_0(\PP)$ such that
\begin{itemize}
\item[(a)]
the domain of the sort \emph{general} in~$I$
  is the set of all precomputed terms;
\item[(b)]
the domain of the sort \emph{integer} in~$I$ is the set of all numerals;
\item[(c)] $I$ interprets every symbolic constant~$c$ in~\emph{PH}
  as~$v(c)$;
\item[(d)] $I$ interprets every precomputed term~$t$ that does not
  belong to~\emph{PH} as~$t$;
\item[(e)] $I$ interprets the symbols for arithmetic operations
  as usual in arithmetic;
\item[(f)] if $p/n$ is a predicate constant from~$\PP$, and $\bf c$
  is an $n$-tuple of precomputed atoms, then $I$ interprets
  $p({\bf c})$ as true iff $p({\bf c})\in\I$;
\item[(g)] $I$ interprets the comparison symbols as in the definition of
  mini-\gringo.
\end{itemize}
We will denote that interpretation by~$I(v,\I)$.
The domain of the user guide is the set of inputs $(v,\I)$ such that
the interpretation $I(v,\I)$ of~$\sigma_0(\emph{In})$ satisfies all
assumptions in the \verb|assume| statements.

\medskip\noindent{\bf Example~1, continued}$\;$ The user guide $\emph{UG}_p$
can be described by the statements
\begin{verbatim}
  input: a, b.
  assume: exists N (a = N) and exists N (b = N).
  assume: a > 1.
  output: prime/1.
\end{verbatim}
The first two lines can be written be more concisely as
\begin{verbatim}
  input: a -> integer, b -> integer.
\end{verbatim}

\medskip\noindent{\bf Example~2, continued}$\;$ The user guide $\emph{UG}_o$
can be described by the statements
\beq\ba l
\verb| input: living/1, father/2, mother/2.|\\
\verb| output: orphan/1.|
\ea\eeq{ugo}
The absence of \verb|assume| statements shows that the domain of this
user guide is the set of all inputs.

\section{Proof assistant {\sc anthem-p2p}}

{\sc anthem-p2p} is built on top of the proof assistant \anthem\
\cite{fan20}; the relationship between these two systems is discussed in
Section~\ref{sec:ontop}.

To give an example of its use,
we can verify that the first two versions of the prime number program
from the introduction are equivalent with respect to the user guide
$\emph{UG}_p$ by running {\sc anthem-p2p} on the following input files: the
unsafe program
\begin{verbatim}
  composite(I*J) :- I > 1, J > 1.
        prime(I) :- I = a..b, not composite(I).
\end{verbatim}
the safe program
\begin{verbatim}
  composite(I*J) :- I = 2..b, J = 2..b.
        prime(I) :- I = a..b, not composite(I).
\end{verbatim}
and the user guide
\begin{verbatim}
  input: a -> integer, b -> integer.
  assume: a > 1.
  output: prime/1.
\end{verbatim}
%%%
{\sc anthem-p2p} transforms the task of verifying equivalence
with respect to a user guide~(\ref{ug}) into the problem of verifying
the provability of a formula in a first-order theory over the
signature~$\sigma_0(\emph{In}\cup\emph{Out})$,
and submits that problem to \vampire.  This reduction is based on the theorem
presented in Section~\ref{sec:tight}.

%%%
The user can help \vampire\ organize search more efficiently by
supplying {\sc anthem-p2p} with ``helper'' files.  Such a file may instruct
\vampire\ to prove a series of lemmas before trying to prove the goal formula.
A helper file can suggest also instances of the induction schema that may be
useful for the job in hand.

%%%
The use of {\sc anthem-p2p} for proving
equivalence of programs is, generally, an interactive process.
If \vampire\ does not prove the goal formula in the allotted time then one of
the options is to give \vampire\ more lemmas to work on and run it
again.  Alternatively, the user can look for a counterexample that refutes the
%%%
equivalence claim, as in Example~2 above.

Sometimes, {\sc anthem-p2p} can 
help us clarify the source of a puzzling discrepancy between two versions
of a program if we run it in the presence of additional \verb|assume|
statements.  If
adding an assumption to the user guide makes the programs equivalent then
it is possible that perceiving that assumption as self-evident
is the reason why the discrepancy is puzzling.  For
instance, we can observe that
%%%
the {\sc anthem-p2p}/\vampire\ team
proves the equivalence of
program~(\ref{orphan1}) to program~(\ref{orphan2}) if we extend user
guide~(\ref{ugo}) by two existence and uniqueness assumptions:
\begin{verbatim}
  assume: forall X exists Y forall Z (father(Z,X) <-> Y=Z).
  assume: forall X exists Y forall Z (mother(Z,X) <-> Y=Z).
\end{verbatim}

\section{Equivalence of tight programs}\label{sec:tight}

[ Review the definition of a tight program. ]
\bigskip

The theorem stated below relates equivalence of tight programs to the
%%%
satisfaction relation of second-order logic.  Its statement refers to
the concept of second-order completion, reviewed in Appendix~\ref{appb},
and also to the concept of  standard interpretation, defined as follows.
An interpretation~$I$ of~$\sigma_0(\PP)$ is \emph{standard} for a
set~\emph{PH} of symbolic constants if it
satisfies conditions~(a), (b), (d), (e), (g)
from Section~\ref{sec:fn} and the condition
\begin{itemize}
\item[(c$'$)] $I$ interprets every symbolic constant~$c$ in~\emph{PH}
  as a term that does not belong to~\emph{PH}.
\end{itemize}

\medskip\noindent{\bf Theorem}$\;$\emph{
  Let~UG be a user guide (PH,In,Out,Dom) such that its domain is described by
  a finite set of assumptions, and let Asm be the conjunction of these
  assumptions.
  For any tight mini-\gringo\ programs $\Pi_1$,~$\Pi_2$ such that the
  heads of their rules do not contain the input symbols of~UG,
$\Pi_1$ is equivalent to~$\Pi_2$ with respect to UG iff the sentence}
\beq
\emph{Asm}\to(\hbox{COMP}(\Pi_1,\emph{In},\emph{Out\/}) \lrar
\hbox{COMP}(\Pi_2,\emph{In},\emph{Out\/}))
\eeq{thmf}
\emph{is satisfied by all interpretations of the
  signature~$\sigma_0$(In\,$\cup$Out) that are standard for~PH.}
\medskip

This theorem shows that the equivalence of tight programs may be established
by choosing a first-order theory~$T$ over the
signature~$\sigma_0(\emph{In\/}\cup\emph{Out})$ such that its axioms are
satisfied by all interpretations that are
standard for~\emph{PH}, and then deriving
formula~(\ref{thmf}) from the axioms of~$T$ in classical second-order logic.
As discussed in Appendix~\ref{appb}, under some conditions the
subformulas COMP($\Pi_i$,\emph{In\/},\emph{Out\/}) of~(\ref{thmf}) can be
equivalently rewritten as first-order formulas.  Then
establishing the equivalence of~$\Pi_1$ to~$\Pi_2$ can be reduced to
deriving a formula from the axioms of~$T$ in first-order logic.
This is the core of the procedure used by {\sc anthem-p2p}.  Some
details are provided in Section~\ref{sec:ontop}.

The proof of the theorem, including the lemma below, uses
terminology related to io-programs, which
is reviewed in Appendix~\ref{appc}.

\medskip\noindent{\bf Lemma}$\;$\emph{
Let~$\Pi$ be a mini-\gringo\ program such that the heads of its rules do not
contain input symbols of a user guide}
(\emph{PH},\emph{In},\emph{Out},\emph{Dom\/}). \emph{For any
  input~$(v,\I)$, a set~$\J$ of
  output atoms is an element of the external behavior
  of~$\Pi$ for} (\emph{PH},\emph{In},\emph{Out},\emph{Dom\/})
\emph{and $(v,\I)$ iff
$\I\cup\J$ is an io-model of the io-program}
($\Pi$,\emph{PH},\emph{In},\emph{Out}) \emph{for $(v,\I)$.}

\medskip\noindent{\bf Proof}$\;$
We need to show that, for any set~$\J$ of output atoms, the following
conditions are equivalent:
\begin{itemize}
\item[(i)] $\J$ is the set of all output atoms in some stable model~$\M$ 
  of $v(\Pi)\cup\I$;
\item[(ii)] $\I\cup\J$ is the set of all public atoms in some stable
  model~$\M$ of $v(\Pi)\cup\I$.
\end{itemize}
The heads of rules of~$v(\Pi)$ do not contain input atoms.  Hence
the set of input atoms in~$\M$ is~$\I$, which implies the equivalence
between conditions~(i) and~(ii).

\medskip\noindent{\bf Proof of the Theorem}$\;$
The condition
\beq
\Pi_1\hbox{ is equivalent to }\Pi_2\hbox{ with respect to }\emph{UG}
\eeq{pt1}
means that for any input $(v,\I)$ such that $I(v,\I)\models\emph{Asm}$
and any set~$\J$ of output atoms,
\beq\ba c
\J\hbox{ is an element of the external behavior
  of~$\Pi_1$ for \emph{UG} and }(v,\I)\\
\hbox{iff}\\
\J\hbox{ is an element of the external behavior
  of~$\Pi_2$ for \emph{UG} and }(v,\I).
\ea\eeq{pt2}
By the lemma, condition~(\ref{pt2}) can be reformulated as follows:
$$\ba c
\I\cup\J\hbox{ is an io-model of the io-program
($\Pi_1$,\emph{PH},\emph{In},\emph{Out}) for }(v,\I)\\
\hbox{iff}\\
\I\cup\J\hbox{ is an io-model of the io-program
($\Pi_2$,\emph{PH},\emph{In},\emph{Out}) for }(v,\I).\\
\ea$$
By the theorem quoted at the end of Appendix~\ref{appc}, this can be further
reformulated as
\beq I(v,\I\cup\J) \models
\hbox{COMP($\Pi_1$,\emph{In\/},\emph{Out\/})}
\lrar
\hbox{COMP($\Pi_2$,\emph{In\/},\emph{Out\/})}.
\eeq{pt3}
Hence condition~(\ref{pt1}) is equivalent to requiring that~(\ref{pt3})
hold for all inputs $(v,\I)$ such that
$I(v,\I)\models\emph{Asm}$ and all set~$\J$ of output atoms.

Since assumptions do not contain output symbols,
$I(v,\I)\models\emph{Asm}$ is equivalent to $I(v,\I\cup\J)\models\emph{Asm}$.
It follows that~(\ref{pt1}) is equivalent to asserting that
implication~(\ref{thmf}) is satisfied by $I(v,\I\cup\J)$ for all
inputs $(v,\I)$ and all sets~$\J$ of output atoms.  It remains to observe
that an interpretation of the
signature~$\sigma_0(\emph{In\/}\cup\emph{Out\/})$ can be represented in
the form $I(v,\I\cup\J)$ if and only if it is
standard for~\emph{PH}.

\section{Design of {\sc anthem-p2p}} \label{sec:ontop}

\section{Conclusion}

\section*{Acknowledgements}

Thanks to Michael Gelfond for comments on a draft of this paper.

\bibliographystyle{acmtrans}
\bibliography{bib}

\appendix

\section{Two-sorted formulas} \label{appa}

The signature~$\sigma_0$ \cite[Section~2.2]{fan22}
has two sorts: the sort \emph{generic} and its subsort
\emph{integer}.
Variables of the first sort are meant to
range over arbitrary precomputed terms, and we will identify them with
variables used in mini-\gringo\ rules.  Variables of the second sort are meant
to range over numerals (or, equivalently, integers).\footnote{The need to
  use a language with two sorts is explained by the fact that function symbols
in a first-order language are supposed to represent total functions, and
arithmetic operations are not defined on symbolic constants.}
The signature includes
\begin{itemize}
\item all precomputed terms as object constants; an object constant
  is assigned the sort \emph{integer} iff it is a numeral;
\item the symbols~$+$, $-$ and~$\times$ as binary function constants;
  their arguments and values have the sort \emph{integer};
\item all predicate symbols~$p/n$ as $n$-ary predicate
  constants; their arguments have the sort \emph{general};
\item the comparison symbols
$$\neq\quad<\quad>\quad\leq\quad\geq$$
as binary predicate constants; their arguments have the sort \emph{general}.
\end{itemize}
(Equality is not mentioned here because it is considered part of any
first-order language.)  An atomic formula $(p/n)({\bf t})$ can be abbreviated
as $p({\bf t})$. An atomic formula $\prec\!\!(t_1,t_2)$, where~$\prec$ is a
comparison symbol, can be written as $t_1\prec t_2$.

We follow the convention adopted in {\sc anthem\/}:
general variables start with $U$, $V$, $W$, $X$, $Y$, and $Z$;
integer variables start with $I$, $J$, $K$, $L$, $M$, and $N$.
For example, the formula
$\exists X (N=X)$ expresses that the value of~$N$ is an object of the sort
\emph{general\/};  it is universally true, because \emph{integer} is a
subsort of \emph{general}.  The formula
$\exists N (N=X)$ expresses that the value of~$X$ is an object of the sort
\emph{integer\/}; it is generally not true.

\section{Second-order completion} \label{appb}

Second-order completion \cite[Sections~6.1,~6.2]{fan20}
is a generalization of Clark's completion
\cite{cla78} that uses bound predicate variables to model auxiliary
(``private'') predicates, such as \verb|composite/1| in our prime number
programs.  The definition covering the full
syntax of mini-\gringo\ is rather lengthy, and in this appendix we only give
an outline and an example.

Let \emph{In} and \emph{Out} be disjoint sets of predicate symbols, and
let~$\Pi$ be a mini-\gringo\ program such that atoms in the heads of
its rules do not contain predicate symbols from \emph{In}.
If a predicate symbol~$p/n$
\begin{itemize}
\item is contained in an atom that occurs in a rule of~$\Pi$, and
\item belongs neither to~\emph{In} nor to~\emph{Out},
\end{itemize}
then we say~$p/n$ is a \emph{private symbol} of~$\Pi$.  We denote the
set of private symbols of~$\Pi$ by~\emph{Prv}.

The \emph{first-order completion} of~$\Pi$ is the conjunction of several
first-order sentences over the
signature~$\sigma_0(\emph{In\/}\cup\emph{Out\/}\cup\emph{Prv\/})$:
\begin{itemize}
\item the completed definitions of the predicate symbols
  from~$\emph{Out\/}\cup\emph{Prv\/}$ in~$\Pi$, and
\item the constraints of~$\Pi$ rewritten in the syntax of first-order
  logic.
\end{itemize}
The \emph{second-order completion} of~$\Pi$ is the second-order sentence
over the signature~$\sigma_0(\emph{In\/}\cup\emph{Out\/})$ obtained from
the first-order completion of~$\Pi$ by replacing all private symbols by
predicate variables and binding these variables by an 1existential quantifier.
We will denote the second-order completion of~$\Pi$ by
COMP$(\Pi,\emph{In\/},\emph{Out\/})$.

If, for instance, $\emph{In}=\emptyset$, $\emph{Out}=\{q/2\}$, and~$\Pi$
is the program
$$
\ba l
p(a),\\
p(b),\\
q(X,Y) \ar p(X) \land p(Y),
\ea$$
then $\emph{Prv}=\{p/1\}$,
the first-order completion of~$\Pi$ is
$$\ba l
\forall V(p(V) \lrar V=a \lor V=b)\,\land\\
\forall V_1V_2(q(V_1,V_2) \lrar \exists XY(q(V_1,V_2) \land p(X) \land p(Y)
\land V_1=X \land V_2=Y)),
\ea$$
and COMP$(\Pi,\emph{In\/},\emph{Out\/})$ is
$$
\ba l
\exists P(\forall V(P(V) \lrar V=a \lor V=b)\,\land\\
\forall V_1V_2(q(V_1,V_2) \lrar \exists XY(q(V_1,V_2) \land
P(X) \land P(Y) \land V_1=X \land V_2=Y))).
\ea
$$

Second-order quantifiers in completion formulas can be eliminated if~$\Pi$
is ``free from private recursion''
\cite[Section~6.4]{fan20}.  For instance, the second-order formula above
is equivalent to the first-order formula
$$
\forall V_1V_2(q(V_1,V_2) \lrar (V_1=a \lor V_1=b)\land(V_2=a \lor V_2=b)).
$$

\section{Programs with input and output} \label{appc}

A \emph{program with input and output}, or an \emph{io-program},
is a quadruple
\beq
(\Pi,\emph{PH},\emph{In},\emph{Out\/}),
\eeq{iop}
where \emph{PH}, \emph{In} and \emph{Out} are as in the definition of
a user guide (Section~\ref{sec:ug}), and~$\Pi$ is a mini-\gringo\ program
such that the heads of its rules do not contain symbols from \emph{In}
\cite[Section~5.1]{fan20}.  Inputs for an io-program are defined in the same
way as inputs for a user guide in Section~\ref{sec:ug}.

A \emph{public atom} of an io-program~(\ref{iop}) is a precomputed atom
that contains a predicate symbol from $\emph{In\/}\cup\emph{Out\/}$.

An \emph{io-model} of an io-program~(\ref{iop}) for an input $(v,\I)$ is
a set that can be represented as the intersection of a stable model
of $v(\Pi)\cup\I$ with the set of public atoms of~(\ref{iop}).

If~$(v,\I)$ is an input for an io-program~(\ref{iop}), and the program~$\Pi$
is tight, then, for any set~$\J$ of output atoms, $\I\cup\J$ is an io-model
of~(\ref{iop}) iff the interpretation $I(v,\I\cup\J)$ of the
signature~$\sigma_0(\emph{In\/}\cup\emph{Out\/})$ satisfies the
second-order completion sentence COMP$(\Pi,\emph{In\/},\emph{Out\/})$
\cite[Theorem~2]{fan20}.




\end{document}

The proof of the theorem is given in Section~\ref{sec:proof}.

\section{Programs without private recursion}

In the special case when the io-programs
$(\Pi_1,\emph{PH},\emph{In},\emph{Out\/})$ and
$(\Pi_2,\emph{PH},\emph{In},\emph{Out\/})$ do not involve private recursion
\cite[Section~6.4]{fan20}, the use of second-order logic can be avoided in the
following way.  Represent the formula
COMP$(\Pi_1,\emph{In\/},\emph{Out\/})$ in the form
$$\exists {\bf P}\left(\bigwedge_i F_i({\bf P}) \land F'({\bf P})\right),$$
where $\bf P$ is a list
% $P_1,P_2,\dots$
of distinct predicate variables
corresponding to the
private symbols\footnote{A \emph{private symbol} of an io-program is
  a predicate symbol that occurs in its rules and is different from its
  input symbols and output symbols \cite[Section~5.1]{fan20}.}
$p_1,p_2,\dots$
of $(\Pi_1,\emph{PH},\emph{In},\emph{Out\/})$, and~$F_i({\bf P})$ is
the formula obtained from the completed definition \cite[Section~6.1]{fan20}
of~$p_i$ in~$\Pi_1$ by replacing each of $p_1,p_2,\dots$ by the
corresponding member of~$\bf P$. (The conjunctive members
of $F'({\bf P})$ correspond to the completed definitions of the output
symbols and to the constraints of~$\Pi_1$.)  Similarly, write
COMP$(\Pi_2,\emph{In\/},\emph{Out\/})$ as
\beq
\exists {\bf Q}\left(\bigwedge_j G_j({\bf Q}) \land G'({\bf Q})\right),
\eeq{comp2}
where $\bf Q$ is a list of distinct predicate variables corresponding to the
private symbols
of $(\Pi_2,\emph{PH},\emph{In},\emph{Out\/})$,
and the formulas $G_j({\bf Q})$ are obtained from the completed
definitions of these symbols in~$\Pi_2$ by replacing each of them
by the corresponding variable.  Take one half
\beq
\emph{Asm}\to(\hbox{COMP}(\Pi_1,\emph{In},\emph{Out\/}) \to
\hbox{COMP}(\Pi_2,\emph{In},\emph{Out\/}))
\eeq{thmf1}
of condition~(\ref{thmf}).
Since~$\Pi_2$ does not use private
recursion, formula~(\ref{comp2}) is equivalent to
$$\forall {\bf Q}\left(\bigwedge_j G_j({\bf Q}) \to G'({\bf Q})\right)$$
\cite[Theorem~3]{fan20}.  It follows that formula~(\ref{thmf1}) is
equivalent to
$$
\emph{Asm}\to
 \left(\exists {\bf P}\left(\bigwedge_i F_i({\bf P}) \land F'({\bf P})\right)
 \to\forall {\bf Q}\left(\bigwedge_j G_j({\bf Q}) \to G'({\bf Q})\right)\right)
$$
and consequently to
$$
\forall {\bf PQ}\left(\left(
    \emph{Asm}\land\bigwedge_i F_i({\bf P}) 
\land\bigwedge_j G_j({\bf Q}) \right) \to (F'({\bf P})\to G'({\bf Q}))\right)
$$
(with the bound variables in {\bf P}, {\bf Q} renamed, if necessary, to ensure
that they are pairwise disjoint).
Similarly, the second half
$$%\beq
\emph{Asm}\to(\hbox{COMP}(\Pi_2,\emph{In},\emph{Out\/}) \to
\hbox{COMP}(\Pi_1,\emph{In},\emph{Out\/}))
$$%\eeq{thmf12}
of condition~(\ref{thmf}) is equivalent to
$$
\forall {\bf PQ}\left(\left(
    \emph{Asm}\land\bigwedge_i F_i({\bf P}) 
\land\bigwedge_j G_j({\bf Q}) \right) \to (G'({\bf P})\to F'({\bf Q}))\right).
$$
Thus~(\ref{thmf}) can be rewritten as
$$
\forall {\bf PQ}\left(\left(
   \emph{Asm}\land\bigwedge_i F_i({\bf P}) 
   \land\bigwedge_j G_j({\bf Q}) \right) \to
          (F'({\bf P})\lrar G'({\bf Q}))\right).
$$
Finally, observe that
the derivability of this formula from \emph{Ax} is equivalent to the
derivability of the first-order formula
\beq
\left(
    \emph{Asm}\land\bigwedge_i F_i({\bf p})
\land\bigwedge_j G_j({\bf q}) \right) \to (F'({\bf p})\lrar G'({\bf q})),
\eeq{thmffo}
where {\bf p}, {\bf q} are lists of fresh predicate constants.

\section{Replacing programs by specifications}

We see that, under some conditions, proving the
equivalence of mini-\gringo\ programs can be reduced to deriving
formulas of form~(\ref{thmffo}).  This reduction is similar to the process of
proving program correctness that is implemented in \hbox{\anthem} \cite{fan20}.
The difference is that we talk here about the equivalence of a program to
another program, instead of the equivalence of a program to a specification.

The relationship between proving the equivalence of programs and the
operation of \anthem\ can be described also in a different way.
Define a specification~$\Sfr$ as follows:
\begin{itemize}
\item
the placeholders of~$\Sfr$ are the placeholders~\emph{PH} of user guide~(\ref{ug});
  \item
    the input symbols of~$\Sfr$ are the input symbols~\emph{In} of the user guide
    and the private symbols~{\bf p} of the io-program
$(\Pi_1,\emph{PH},\emph{In},\emph{Out\/})$;
\item
  the assumptions of~$\Sfr$ are the assumptions~\emph{Asm} of the user guide
  and the formulas~$F_i({\bf p})$;
\item
  the specs of~$\Sfr$ are the conjunctive terms of $F'({\bf p})$.
\end{itemize}
If we instruct \anthem\ to prove the claim
that the io-program $(\Pi_2,\emph{PH},\emph{In},\emph{Out})$
implements~$\Sfr$, then \anthem\ will look for a derivation of the formula
$$\left(
    \emph{Asm}\land\bigwedge_i F_i({\bf p})
\land\bigwedge_j G_j({\bf q}) \right) \to (G'({\bf q})\lrar F'({\bf p}))
$$
from \emph{Ax} \cite[Section~6.4]{fan20}.
This formula is equivalent to~(\ref{thmffo}).
Thus instructing \anthem\ to verify that
the io-program $(\Pi_1,\emph{PH},\emph{In},\emph{Out})$
implements the specification~$\Sfr$ amounts verifying the derivability
of~(\ref{thmffo}).

\section{Implementation}\label{sec:implementation}

[ Use the example from the introduction. ]



\section{The language of assumptions}


\end{document}

User guides can be represented in the format of {\sc anthem} specification
files.  For example, the file
\begin{verbatim}
  input: a, b.
  assume: exists N (a = N) and exists N (b = N).
  assume: a > 1.
  output: prime/1.
\end{verbatim}
represents user guide~(\ref{ug}) with
The first two lines in that file can be written more concisely as
\begin{verbatim}
  input: a -> integer, b -> integer.
\end{verbatim}
Unlike general specification files, user guide files do not contain
\verb|spec| statements.

\section{External behavior and equivalence}

For any interpretation~$I$ of the signature~$\sigma(\emph{In})$
and any function~$v$ that maps
symbolic constants to precomputed terms, by $v[I]$ we denote the
interpretation obtained from~$I$ by reinterpreting every
constant~$c$ in the domain of~$v$ according to the formula
$$v[I](c)= I(v(c)).$$

An~\emph{input} for a user guide~\emph{UG} is a pair $(v,\I)$, where
\begin{itemize}
\item[(i)]
  $v$ is a function that maps the placeholders of~\emph{UG} to precomputed
terms that are not placeholders, and
\item[(ii)]
  $\I$ is a subset of the set of input atoms of~\emph{UG} such that
  the interpretation~$v[\I^\uparrow]$ satisfies the assumptions
  of~\emph{UG}.\footnote{The meaning of~$\I^\uparrow$ is defined in the
    appendix.}
\end{itemize}
\bibliographystyle{named}
\bibliography{bib}
\end{document}
